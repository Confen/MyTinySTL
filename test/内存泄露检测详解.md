# MyTinySTL 内存泄露检测系统详解

## 1. 系统概述

MyTinySTL 的内存泄露检测系统是一个完整的内存管理和调试工具集，旨在帮助开发者在开发阶段发现和定位内存泄露问题。

### 1.1 核心组件

- **memory_manager**: 内存管理器，统计全局内存使用情况
- **memory_debug**: 内存调试器，记录分配/释放操作
- **memory_leak_detector**: 内存泄露检测器，维护详细的分配记录

### 1.2 设计特点

- ✅ **零开销**: 发布版本完全无性能影响
- ✅ **精确定位**: 提供文件名和行号信息
- ✅ **实时监控**: 可随时检查内存状态
- ✅ **异常安全**: 支持异常情况下的内存跟踪

## 2. 检测原理详解

### 2.1 数据结构设计

```cpp
struct allocation_info {
    void* ptr;              // 分配的指针地址
    size_t size;            // 分配的内存大小
    const char* file;       // 分配发生的文件名
    int line;               // 分配发生的行号
    allocation_info* next;  // 链表指针
};
```

### 2.2 工作流程

#### 分配阶段
1. 调用 `MYTINYSTL_ALLOC(size)` 宏
2. 执行 `std::malloc(size)` 分配内存
3. 创建 `allocation_info` 节点
4. 记录指针、大小、文件名、行号
5. 将节点插入到全局链表头部

#### 释放阶段
1. 调用 `MYTINYSTL_FREE(ptr, size)` 宏
2. 在链表中查找匹配的指针
3. 从链表中移除对应节点
4. 执行 `std::free(ptr)` 释放内存
5. 删除 `allocation_info` 节点

#### 检测阶段
1. 调用 `memory_leak_detector::check_leaks()`
2. 遍历全局链表
3. 链表中剩余的节点即为泄露的内存
4. 输出详细的泄露信息

### 2.3 核心算法

```cpp
// 记录分配
static void record_allocation(void* ptr, size_t size, const char* file, int line) {
    allocation_info* info = new allocation_info;
    info->ptr = ptr;
    info->size = size;
    info->file = file;
    info->line = line;
    info->next = allocations_;  // 插入链表头部
    allocations_ = info;
    total_allocated_ += size;
}

// 记录释放
static void record_deallocation(void* ptr) {
    allocation_info** current = &allocations_;
    while (*current) {
        if ((*current)->ptr == ptr) {
            allocation_info* to_delete = *current;
            *current = (*current)->next;  // 从链表中移除
            total_allocated_ -= to_delete->size;
            delete to_delete;
            return;
        }
        current = &(*current)->next;
    }
}
```

## 3. 使用方法

### 3.1 启用检测

```cpp
// 方法1: 编译时定义宏
#define MYTINYSTL_DEBUG

// 方法2: 编译命令行参数
g++ -DMYTINYSTL_DEBUG -std=c++11 -I.. your_file.cpp
```

### 3.2 基本用法

```cpp
#include "../memory.h"

int main() {
    // 启用调试
    mystl::memory_debug::enable_debug();
    
    // 分配内存
    void* ptr = MYTINYSTL_ALLOC(1024);
    
    // 检查泄露
    mystl::memory_leak_detector::check_leaks();
    
    // 释放内存
    MYTINYSTL_FREE(ptr, 1024);
    
    // 再次检查
    mystl::memory_leak_detector::check_leaks();
    
    return 0;
}
```

### 3.3 与智能指针配合

```cpp
// 推荐：使用智能指针（自动管理）
auto smart_ptr = mystl::make_unique<MyClass>(args);

// 不推荐：使用裸指针（容易泄露）
MyClass* raw_ptr = new MyClass(args);
// 忘记 delete raw_ptr; 会导致泄露
```

## 4. 测试场景

### 4.1 无泄露场景

```cpp
void test_no_leak() {
    mystl::memory_debug::reset();
    mystl::memory_leak_detector::reset();
    
    {
        auto obj = mystl::make_unique<TestClass>(100);
        // 智能指针自动管理内存
    }
    
    mystl::memory_leak_detector::check_leaks();  // 应该显示无泄露
}
```

### 4.2 有泄露场景

```cpp
void test_with_leak() {
    mystl::memory_debug::reset();
    mystl::memory_leak_detector::reset();
    
    {
        TestClass* obj = new TestClass(100);
        // 故意不删除，造成泄露
    }
    
    mystl::memory_leak_detector::check_leaks();  // 显示泄露信息
}
```

### 4.3 部分泄露场景

```cpp
void test_partial_leak() {
    mystl::memory_debug::reset();
    mystl::memory_leak_detector::reset();
    
    TestClass* obj1 = new TestClass(100);
    TestClass* obj2 = new TestClass(200);
    TestClass* obj3 = new TestClass(300);
    
    delete obj1;  // 正常释放
    delete obj2;  // 正常释放
    // obj3 未释放，造成泄露
    
    mystl::memory_leak_detector::check_leaks();  // 显示obj3泄露
}
```

## 5. 输出解读

### 5.1 正常情况输出

```
=== 内存调试摘要 ===
分配次数: 3
释放次数: 3
未释放次数: 0

没有检测到内存泄漏
```

### 5.2 泄露情况输出

```
=== 内存调试摘要 ===
分配次数: 3
释放次数: 2
未释放次数: 1

=== 检测到内存泄漏 ===
泄漏: 0x1a2b3c4d, 大小: 400, 文件: test.cpp, 行: 25
总泄漏大小: 400 字节
```

### 5.3 内存管理器状态

```
=== 内存管理器状态 ===
总分配: 1200 字节
总释放: 800 字节
当前使用: 400 字节
峰值使用: 1200 字节
```

## 6. 最佳实践

### 6.1 RAII 原则

```cpp
// 好的做法：使用RAII
{
    auto resource = mystl::make_unique<Resource>();
    // 自动清理，无需手动管理
}

// 不好的做法：手动管理
{
    Resource* resource = new Resource();
    // 容易忘记 delete，导致泄露
}
```

### 6.2 异常安全

```cpp
// 异常安全的资源管理
try {
    auto obj = mystl::make_unique<MyClass>();
    // 即使抛出异常，智能指针也会自动清理
    risky_operation();
} catch (...) {
    // 资源已被自动清理
}
```

### 6.3 定期检测

```cpp
void critical_function() {
    // 函数开始时重置计数器
    mystl::memory_debug::reset();
    mystl::memory_leak_detector::reset();
    
    // 执行业务逻辑
    do_complex_operations();
    
    // 函数结束时检查泄露
    mystl::memory_leak_detector::check_leaks();
}
```

## 7. 性能考虑

### 7.1 调试模式开销

- **时间开销**: 每次分配/释放增加约10-20%时间
- **空间开销**: 每个分配增加约32字节元数据
- **适用场景**: 仅在开发和测试阶段使用

### 7.2 发布模式优化

```cpp
#ifdef MYTINYSTL_DEBUG
    // 调试版本：完整跟踪
    #define MYTINYSTL_ALLOC(size) /* 复杂的跟踪逻辑 */
#else
    // 发布版本：直接调用
    #define MYTINYSTL_ALLOC(size) std::malloc(size)
#endif
```

## 8. 常见问题

### 8.1 误报情况

- **静态对象**: 程序结束时的静态对象析构可能被误报
- **第三方库**: 第三方库的内存分配不会被跟踪
- **系统调用**: 直接的系统内存调用不会被检测

### 8.2 解决方案

```cpp
// 忽略静态对象的泄露检测
void cleanup_before_exit() {
    // 在程序退出前清理检测器
    mystl::memory_leak_detector::reset();
}
```

### 8.3 调试技巧

```cpp
// 使用作用域限制检测范围
void test_specific_function() {
    mystl::memory_debug::reset();
    mystl::memory_leak_detector::reset();
    
    {
        // 只检测这个作用域内的内存操作
        specific_function_to_test();
    }
    
    mystl::memory_leak_detector::check_leaks();
}
```

## 9. 扩展功能

### 9.1 自定义分配器

```cpp
template<typename T>
class debug_allocator {
public:
    T* allocate(size_t n) {
        T* ptr = static_cast<T*>(MYTINYSTL_ALLOC(n * sizeof(T)));
        return ptr;
    }
    
    void deallocate(T* ptr, size_t n) {
        MYTINYSTL_FREE(ptr, n * sizeof(T));
    }
};
```

### 9.2 内存统计

```cpp
class memory_statistics {
public:
    static void print_detailed_report() {
        std::cout << "=== 详细内存报告 ===" << std::endl;
        mystl::memory_manager::print_status();
        mystl::memory_debug::print_summary();
        mystl::memory_leak_detector::check_leaks();
    }
};
```

## 10. 总结

MyTinySTL 的内存泄露检测系统提供了：

1. **完整的内存跟踪**: 从分配到释放的全生命周期监控
2. **精确的错误定位**: 提供文件名和行号信息
3. **灵活的使用方式**: 支持条件编译和运行时控制
4. **优秀的性能特性**: 发布版本零开销
5. **丰富的调试信息**: 多层次的内存使用统计

通过合理使用这个系统，开发者可以有效地发现和解决内存泄露问题，提高程序的稳定性和可靠性。
